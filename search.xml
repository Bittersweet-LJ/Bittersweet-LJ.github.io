<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go函数返回局部变量的指针是否安全?</title>
      <link href="/2023/02/25/Go%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8/"/>
      <url>/2023/02/25/Go%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Go函数返回局部变量的指针是否安全"><a href="#Go函数返回局部变量的指针是否安全" class="headerlink" title="Go函数返回局部变量的指针是否安全?"></a>Go函数返回局部变量的指针是否安全?</h1><h2 id="参考解析"><a href="#参考解析" class="headerlink" title="参考解析"></a>参考解析</h2><p>一般来说，局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。</p><p>但这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上，因为他们不在栈区，即使释放函数，其内容也不会受影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line">res = x + y</span><br><span class="line"><span class="keyword">return</span> &amp;res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子中，函数 <code>add</code> 局部变量 <code>res</code> 发生了逃逸。res作为返回值，在 main 函数中继续使用，因此 res 指向的内存不能够分配在栈上，随着函数结束而回收，只能分配在堆上。</p><p>编译时可以借助选项 <code>-gcflags=-m</code>，查看变量逃逸的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./main.go:6:2: res escapes to heap:</span><br><span class="line">./main.go:6:2:   flow: ~r2 = &amp;res:</span><br><span class="line">./main.go:6:2:     from &amp;res (address-of) at ./main.go:8:9</span><br><span class="line">./main.go:6:2:     from return &amp;res (return) at ./main.go:8:2</span><br><span class="line">./main.go:6:2: moved to heap: res</span><br><span class="line">./main.go:12:13: ... argument does not escape</span><br><span class="line">0xc0000ae008</span><br></pre></td></tr></table></figure><p><code>res escapes to heap</code> 即表示 <code>res</code> 逃逸到堆上了。</p><h2 id="知识点补充—–go中的堆和栈"><a href="#知识点补充—–go中的堆和栈" class="headerlink" title="知识点补充—–go中的堆和栈"></a>知识点补充—–go中的堆和栈</h2><p>我们定义的变量存放在堆还是栈中？一般是这么来分配的</p><p>堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式类似于链表</p><p>栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><h3 id="那么go中的全局变量和局部变量都是放在哪里呢？"><a href="#那么go中的全局变量和局部变量都是放在哪里呢？" class="headerlink" title="那么go中的全局变量和局部变量都是放在哪里呢？"></a>那么go中的全局变量和局部变量都是放在哪里呢？</h3><h4 id="1-变量的声明周期"><a href="#1-变量的声明周期" class="headerlink" title="1. 变量的声明周期"></a>1. 变量的声明周期</h4><p>生命周期是指程序执行过程中变量存在的时间段。</p><p>（1）包变量(全局变量) 一直常驻在内存中直到程序的结束，然后被系统垃圾回收，也就是说包变量的生命周期是整个程序的执行时间</p><p>（2）局部变量 在函数中定义的变量，它有一个动态的生命周期：每次执行的时候就创建一个新的实体，一直生存到没有人使用(例如没有外部指针指向它，函数退出的时候没有路径访问到这个变量)这个时候它占用的空间就会被回收</p><h4 id="2-堆和栈的分配"><a href="#2-堆和栈的分配" class="headerlink" title="2. 堆和栈的分配"></a>2. 堆和栈的分配</h4><p><a href="https://zhuanlan.zhihu.com/p/523195006">如何判断 Golang 变量是分配在栈（stack）上还是堆（heap）上？</a></p><p>Go语言区别于C&#x2F;C++，虽然变量申请在堆空间上，但是它有自动回收垃圾的功能，所以这些堆地址空间也无需我们手动回收，系统会在需要释放的时刻自动进行垃圾回收。</p><p><strong>总结：Golang 变量存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。非指针小对象通常保存在栈上，大对象保存在堆上。至于指针保存在堆上还是栈上，要进行逃逸分析</strong></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 思考题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 思考题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础算法（一）</title>
      <link href="/2023/02/21/golang%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/21/golang%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言分解质因数"><a href="#Go语言分解质因数" class="headerlink" title="Go语言分解质因数"></a>Go语言分解质因数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个正整数分解质因数。例如：输入 90，打印出 90 &#x3D; 2 * 3 * 3 * 5。</p><h2 id="题目解决思路"><a href="#题目解决思路" class="headerlink" title="题目解决思路"></a>题目解决思路</h2><p>对 n 进行分解质因数，应先找到一个最小的质数 k，然后按下述步骤完成：</p><ol><li>如果这个质数恰等于 n，则说明分解质因数的过程已经结束，打印出即可。</li><li>如果 n 小于最小的质数 k，不能分解质因数，直接打印 n。</li><li>如果 n &gt; k，但 n 能被 k 整除，则应打印出 k 的值，并用 n 除以 k 的商,作为新的正整数 n，重复执行第一步。</li><li>如果 n 不能被 k 整除，则用 k+1 作为 k 的值，重复执行第一步。</li></ol><h2 id="代码具体实现"><a href="#代码具体实现" class="headerlink" title="代码具体实现"></a>代码具体实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n, i <span class="type">int</span> = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;请输入一个数:&quot;</span>)</span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d\n&quot;</span>, &amp;n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d = &quot;</span>, n)</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> n != i &#123;</span><br><span class="line"><span class="keyword">if</span> n % i == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d * &quot;</span>, i)</span><br><span class="line">n = n / i</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下</p><blockquote><p>请输入一个数:100<br>100 &#x3D; 2 * 2 * 5 * 5</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoLand常用快捷键</title>
      <link href="/2022/11/22/goland%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2022/11/22/goland%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Goland快捷键设置"><a href="#Goland快捷键设置" class="headerlink" title="Goland快捷键设置"></a>Goland快捷键设置</h1><h4 id="File-gt-Settings-gt-Keymap"><a href="#File-gt-Settings-gt-Keymap" class="headerlink" title="File-&gt;Settings-&gt;Keymap"></a>File-&gt;Settings-&gt;Keymap</h4><h1 id="GoLand常用快捷键"><a href="#GoLand常用快捷键" class="headerlink" title="GoLand常用快捷键"></a>GoLand常用快捷键</h1><h3 id="1、查询快捷键"><a href="#1、查询快捷键" class="headerlink" title="1、查询快捷键"></a>1、查询快捷键</h3><pre><code>        CTRL+N 查找类        CTRL+SHIFT+N 查找文件        CTRL+SHIFT+ALT+N 查找类中的方法或变量        CTRL+B 快速打开光标处的类或方法        CTRL+ALT+B 找所有的子类        CTRL+SHIFT+B 找变量的类        CTRL+G 定位行        CTRL+F 在当前窗口查找文本        CTRL+SHIFT+F 在指定窗口查找文本        CTRL+R 在 当前窗口替换文本        CTRL+SHIFT+R 在指定窗口替换文本        ALT+SHIFT+C 查找修改的文件        CTRL+E 最近打开的文件        F3 向下查找关键字出现位置        SHIFT+F3 向上一个关键字出现位置        F4 查找变量来源        CTRL+ALT+F7 选中的字符查找工程出现的地方        CTRL+SHIFT+O 弹出显示查找内容        ALT+F1 查找文件所在目录位置        CTRL+H 显示类结构图        CTRL+Q 显示注释文档        CTRL+SHIFT+I 简短查看源定义        CTRL+SHIFT+P 查看表达式类型（在表达式上或者表达式末尾使用）</code></pre><h3 id="2、自动代码"><a href="#2、自动代码" class="headerlink" title="2、自动代码"></a>2、自动代码</h3><pre><code>        Alt+Enter 导入包,自动修正        CTRL+ALT+L 格式化代码        CTRL+ALT+I 自动缩进        CTRL+ALT+O 优化导入的类和包        ALT+INSERT 生成代码(如GET,SET方法,构造函数等)        CTRL+SHIFT+SPACE 自动补全代码        CTRL+空格 代码提示        CTRL+ALT+SPACE 类名或接口名提示        CTRL+P 方法参数提示        CTRL+J 自动代码        CTRL+ALT+T 把选中的代码放在 TRY&#123;&#125; IF&#123;&#125; ELSE&#123;&#125; 里        SHIFT+F6 重构-重命名        CTRL+I 实现接口        CTRL+SHIFT+Space 智能类型推断式返回（return关键字后使用）        CTRL+ALT+V 自动生成表达式返回值        CTRL+ALT+M 重构表达式为函数(光标在表达式末尾)        CTRL+Space 快速返回实现（return关键字后使用）</code></pre><h3 id="3、复制快捷方式"><a href="#3、复制快捷方式" class="headerlink" title="3、复制快捷方式"></a>3、复制快捷方式</h3><pre><code>        CTRL+D 复制行        CTRL+X 剪切,删除行</code></pre><h3 id="4、其他快捷方式"><a href="#4、其他快捷方式" class="headerlink" title="4、其他快捷方式"></a>4、其他快捷方式</h3><pre><code>        CIRL+U 大小写切换        CTRL+Z 倒退        CTRL+SHIFT+Z 向前        CTRL+ALT+F12 资源管理器打开文件夹        SHIFT+ALT+INSERT 竖编辑模式        Ctrl+/ 将当前行代码注释或取消注释        Ctrl+Shift+/ 在当前光标位置添加 /**/ 或将 /*xxxx*/ 内容取消注释        CTRL+W 选中代码，连续按会有其他效果        ALT+ ←/→ 切换代码视图        CTRL+ALT ←/→ 返回上次编辑的位置        ALT+ ↑/↓ 在方法间快速移动定位        ALT+1 快速打开或隐藏工程面板        CTRL+SHIFT+UP/DOWN 代码向上/下移动。        CTRL+UP/DOWN 光标跳转到第一行或最后一行下        ESC 光标返回编辑框        SHIFT+ESC 光标返回编辑框,关闭无用的窗口        ALT+J 相同单词多选        CTRL+SHIFT+A 工具调用        Ctrl+PageUp/PageDown 光标跳转到第一行或最后一行</code></pre>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 编程工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇</title>
      <link href="/2022/11/22/%E5%BC%80%E7%AF%87/"/>
      <url>/2022/11/22/%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="呆呆，晚上好"><a href="#呆呆，晚上好" class="headerlink" title="呆呆，晚上好"></a>呆呆，晚上好</h1><h2 id="嘀嘀嘀"><a href="#嘀嘀嘀" class="headerlink" title="嘀嘀嘀"></a>嘀嘀嘀</h2><div class="fj-gallery"><p><img src="https://source.fomal.cc/img/default_cover_9.webp" alt="p1"><br><img src="https://source.fomal.cc/img/default_cover_10.webp" alt="p2"> </p>          </div>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
