<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go中channel有什么特点</title>
      <link href="/2023/02/26/Go%E4%B8%ADchannel%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9/"/>
      <url>/2023/02/26/Go%E4%B8%ADchannel%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-channel有什么特点？"><a href="#Go-channel有什么特点？" class="headerlink" title="Go channel有什么特点？"></a>Go channel有什么特点？</h1><h2 id="参考解析"><a href="#参考解析" class="headerlink" title="参考解析"></a>参考解析</h2><p>channel有2种类型：无缓冲、有缓冲</p><p>channel有3种模式：写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）</p><table><thead><tr><th align="left"></th><th align="left">写操作模式</th><th align="left">读操作模式</th><th align="left">读写操作模式</th></tr></thead><tbody><tr><td align="left">创建</td><td align="left">make(chan&lt;- int)</td><td align="left">make(&lt;-chan int)</td><td align="left">make(chan int)</td></tr></tbody></table><p>channel有3种状态：未初始化、正常、关闭</p><table><thead><tr><th align="left"></th><th align="left">未初始化</th><th align="left">关闭</th><th align="left">正常</th></tr></thead><tbody><tr><td align="left">关闭</td><td align="left">panic</td><td align="left">panic</td><td align="left">正常关闭</td></tr><tr><td align="left">发送</td><td align="left">永远阻塞导致死锁</td><td align="left">panic</td><td align="left">阻塞或者成功发送</td></tr><tr><td align="left">接收</td><td align="left">永远阻塞导致死锁</td><td align="left">缓冲区为空则为零值, 否则可以继续读</td><td align="left">阻塞或者成功接收</td></tr></tbody></table><p><strong>注意点</strong>：</p><ol><li>一个 channel不能多次关闭，会导致painc</li><li>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都<strong>可能随机被某一个 goroutine 取走进行消费</strong></li><li>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine <strong>都能收到退出信号</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 思考题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 思考题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go内置函数make和new的区别?</title>
      <link href="/2023/02/26/Go%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0make%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/02/26/Go%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0make%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Go内置函数make和new的区别？"><a href="#Go内置函数make和new的区别？" class="headerlink" title="Go内置函数make和new的区别？"></a>Go内置函数make和new的区别？</h1><h2 id="参考解析"><a href="#参考解析" class="headerlink" title="参考解析"></a>参考解析</h2><p>首先纠正下make和new是内置函数，不是关键字</p><p>变量初始化，一般包括2步，变量声明 + 变量内存分配，var关键字就是用来声明变量的，new和make函数主要是用来分配内存的</p><p>var声明<strong>值类型</strong>的变量时，系统会<strong>默认为他分配内存空间</strong>，并赋该类型的<strong>零值</strong></p><p>比如布尔、数字、字符串、结构体</p><p>如果<strong>指针类型</strong>或者<strong>引用类型</strong>的变量，系统<strong>不会为它分配内存</strong>，默认就是<code>nil</code>。此时如果你想<code>直接使用，那么系统会抛异常</code>，必须进行内存分配后，才能使用。</p><p>new 和 make 两个内置函数，主要用来分配内存空间，有了内存，变量就能使用了，主要有以下2点区别：</p><p><strong>使用场景区别：</strong></p><p>make 只能用来分配及初始化类型为slice、map、chan 的数据。</p><p>new 可以分配任意类型的数据，并且置零。</p><p><strong>返回值区别：</strong></p><p>make函数原型如下，返回的是slice、map、chan类型本身</p><p>这3种类型是引用类型，就没有必要返回他们的指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span></span> Type</span><br></pre></td></tr></table></figure><p>new函数原型如下，返回一个指向该类型内存地址的指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span></span> *Type</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 思考题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 思考题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang学习超链接集合</title>
      <link href="/2023/02/25/golang%E5%AD%A6%E4%B9%A0%E8%B6%85%E9%93%BE%E6%8E%A5%E9%9B%86%E5%90%88/"/>
      <url>/2023/02/25/golang%E5%AD%A6%E4%B9%A0%E8%B6%85%E9%93%BE%E6%8E%A5%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<ol><li><h2 id="go-defer-panic-recover详解，-go-的异常处理"><a href="#go-defer-panic-recover详解，-go-的异常处理" class="headerlink" title="go  defer,panic,recover详解， go 的异常处理"></a><a href="https://www.jianshu.com/p/63e3d57f285f">go  defer,panic,recover详解， go 的异常处理</a></h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 超链接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 超链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go函数参数传递到底是值传递还是引用传递？</title>
      <link href="/2023/02/25/Go%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
      <url>/2023/02/25/Go%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h1 id="Go函数参数传递到底是值传递还是引用传递？"><a href="#Go函数参数传递到底是值传递还是引用传递？" class="headerlink" title="Go函数参数传递到底是值传递还是引用传递？"></a>Go函数参数传递到底是值传递还是引用传递？</h1><h2 id="参考解析"><a href="#参考解析" class="headerlink" title="参考解析"></a>参考解析</h2><p><strong>Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。</strong></p><p><strong>参数如果是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；如果是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。</strong></p><p><strong>是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型</strong></p><p><strong>引用类型和引用传递是2个概念，切记</strong>！！！</p><h3 id="什么是值传递？"><a href="#什么是值传递？" class="headerlink" title="什么是值传递？"></a><strong>什么是值传递？</strong></h3><p>将实参的值传递给形参，形参是实参的一份拷贝，实参和形参的内存地址不同。函数内对形参值内容的修改，是否会影响实参的值内容，取决于参数是否是引用类型</p><h3 id="什么是引用传递？"><a href="#什么是引用传递？" class="headerlink" title="什么是引用传递？"></a><strong>什么是引用传递？</strong></h3><p>将实参的地址传递给形参，函数内对形参值内容的修改，将会影响实参的值内容。Go语言是没有引用传递的，在C++中，函数参数的传递方式有引用传递。</p><h3 id="下面分别针对Go的值类型（int、struct等）、引用类型（指针、slice、map、channel），验证是否是值传递，以及函数内对形参的修改是否会修改原内容数据"><a href="#下面分别针对Go的值类型（int、struct等）、引用类型（指针、slice、map、channel），验证是否是值传递，以及函数内对形参的修改是否会修改原内容数据" class="headerlink" title="下面分别针对Go的值类型（int、struct等）、引用类型（指针、slice、map、channel），验证是否是值传递，以及函数内对形参的修改是否会修改原内容数据"></a>下面分别针对Go的值类型（int、struct等）、引用类型（指针、slice、map、channel），验证是否是值传递，以及函数内对形参的修改是否会修改原内容数据</h3><h4 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a><strong>int类型</strong></h4><p>形参和实际参数内存地址不一样，证明是值传递；参数是值类型，所以函数内对形参的修改，不会修改原内容数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int64</span> = <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;原始int内存地址是 %p&quot;</span>, &amp;i)</span><br><span class="line">    modifyInt(i) <span class="comment">// args就是实际参数</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;改动后的值是: %v&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyInt</span><span class="params">(i <span class="type">int64</span>)</span></span> &#123; <span class="comment">//这里定义的args就是形式参数</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;函数里接收到int的内存地址是：%p&quot;</span>, &amp;i)</span><br><span class="line">    i = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原始<span class="type">int</span>内存地址是 <span class="number">0xc0000180b8</span></span><br><span class="line">函数里接收到<span class="type">int</span>的内存地址是：<span class="number">0xc0000180c0</span></span><br><span class="line">改动后的值是: <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a><strong>指针类型</strong></h4><p>形参和实际参数内存地址不一样，证明是值传递，由于形参和实参是指针，指向同一个变量。函数内对指针指向变量的修改，会修改原内容数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> args <span class="type">int64</span> = <span class="number">1</span>                  <span class="comment">// int类型变量</span></span><br><span class="line">    p := &amp;args                          <span class="comment">// 指针类型变量</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;原始指针的内存地址是 %p&quot;</span>, &amp;p)   <span class="comment">// 存放指针类型变量</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;原始指针指向变量的内存地址 %p&quot;</span>, p) <span class="comment">// 存放int变量</span></span><br><span class="line">    modifyPointer(p)                    <span class="comment">// args就是实际参数</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;改动后的值是: %v&quot;</span>, *p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointer</span><span class="params">(p *<span class="type">int64</span>)</span></span> &#123; <span class="comment">//这里定义的args就是形式参数</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;函数里接收到指针的内存地址是 %p &quot;</span>, &amp;p)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;函数里接收到指针指向变量的内存地址 %p&quot;</span>, p)</span><br><span class="line">    *p = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原始指针的内存地址是 <span class="number">0xc000110018</span></span><br><span class="line">原始指针指向变量的内存地址 <span class="number">0xc00010c008</span></span><br><span class="line">函数里接收到指针的内存地址是 <span class="number">0xc000110028</span> </span><br><span class="line">函数里接收到指针指向变量的内存地址 <span class="number">0xc00010c008</span></span><br><span class="line">改动后的值是: <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="slice类型"><a href="#slice类型" class="headerlink" title="slice类型"></a><strong>slice类型</strong></h4><p>形参和实际参数内存地址一样，不代表是引用传递；下面进行详细说明slice还是值传递，传递的是指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s = []<span class="type">int64</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="comment">// &amp;操作符打印出的地址是无效的，是fmt函数作了特殊处理</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;直接对原始切片取地址%v &quot;</span>, &amp;s)</span><br><span class="line">    <span class="comment">// 打印slice的内存地址是可以直接通过%p打印的,不用使用&amp;取地址符转换</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;原始切片的内存地址： %p &quot;</span>, s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;原始切片第一个元素的内存地址： %p &quot;</span>, &amp;s[<span class="number">0</span>])</span><br><span class="line">    modifySlice(s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;改动后的值是: %v&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// &amp;操作符打印出的地址是无效的，是fmt函数作了特殊处理</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;直接对函数里接收到切片取地址%v&quot;</span>, &amp;s)</span><br><span class="line">    <span class="comment">// 打印slice的内存地址是可以直接通过%p打印的,不用使用&amp;取地址符转换</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;函数里接收到切片的内存地址是 %p &quot;</span>, s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;函数里接收到切片第一个元素的内存地址： %p &quot;</span>, &amp;s[<span class="number">0</span>])</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">直接对原始切片取地址&amp;[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] </span><br><span class="line">原始切片的内存地址： <span class="number">0xc0000b8000</span> </span><br><span class="line">原始切片第一个元素的内存地址： <span class="number">0xc0000b8000</span> </span><br><span class="line">直接对函数里接收到切片取地址&amp;[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">函数里接收到切片的内存地址是 <span class="number">0xc0000b8000</span> </span><br><span class="line">函数里接收到切片第一个元素的内存地址： <span class="number">0xc0000b8000</span> </span><br><span class="line">改动后的值是: [<span class="number">10</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><code>slice</code>是一个结构体，他的第一个元素是一个指针类型，这个指针指向的是<strong>底层数组的第一个元素</strong>。当参数是<code>slice</code>类型的时候，fmt.printf通过%p打印的slice变量的地址其实就是内部存储数组元素的地址，所以打印出来形参和实参内存地址一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为slice作为参数时本质是传递的指针，上面证明了指针也是值传递，所以参数为slice也是值传递，指针指向的是同一个变量，函数内对形参的修改，会修改原内容数据</p><p>单纯的从slice这个结构体看，我们可以通过modify修改存储元素的内容，但是永远修改不了len和cap，因为他们只是一个拷贝，如果要修改，那就要传递&amp;slice作为参数才可以。</p><h4 id="map类型"><a href="#map类型" class="headerlink" title="map类型"></a><strong>map类型</strong></h4><p>形参和实际参数内存地址不一样，证明是值传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    m[<span class="string">&quot;age&quot;</span>] = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;原始map的内存地址是：%p&quot;</span>, &amp;m)</span><br><span class="line">    modifyMap(m)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;改动后的值是: %v&quot;</span>, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyMap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;函数里接收到map的内存地址是：%p&quot;</span>, &amp;m)</span><br><span class="line">    m[<span class="string">&quot;age&quot;</span>] = <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原始<span class="keyword">map</span>的内存地址是：<span class="number">0xc00000e028</span></span><br><span class="line">函数里接收到<span class="keyword">map</span>的内存地址是：<span class="number">0xc00000e038</span></span><br><span class="line">改动后的值是: <span class="keyword">map</span>[age:<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>通过make函数创建的map变量本质是一个<code>hmap</code>类型的指针<code>*hmap</code>，所以函数内对形参的修改，会修改原内容数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/runtime/map.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">    mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">        hint = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize Hmap</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h = <span class="built_in">new</span>(hmap)</span><br><span class="line">    &#125;</span><br><span class="line">    h.hash0 = fastrand()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a><strong>channel类型</strong></h4><p>形参和实际参数内存地址不一样，证明是值传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;原始chan的内存地址是：%p&quot;</span>, &amp;p)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(p <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;函数里接收到chan的内存地址是：%p&quot;</span>, &amp;p)</span><br><span class="line">        <span class="comment">//模拟耗时</span></span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        p &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> l := &lt;-p:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;接收到的值是: %v&quot;</span>, l)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原始<span class="keyword">chan</span>的内存地址是：<span class="number">0xc00000e028</span></span><br><span class="line">函数里接收到<span class="keyword">chan</span>的内存地址是：<span class="number">0xc00000e038</span></span><br><span class="line">接收到的值是: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>通过make函数创建的chan变量本质是一个<code>hchan</code>类型的指针<code>*hchan</code>，所以函数内对形参的修改，会修改原内容数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/chan.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">    elem := t.elem</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compiler checks this but be safe.</span></span><br><span class="line">    <span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">        throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="struct类型"><a href="#struct类型" class="headerlink" title="struct类型"></a><strong>struct类型</strong></h4><p>形参和实际参数内存地址不一样，证明是值传递。形参不是引用类型或者指针类型，所以函数内对形参的修改，不会修改原内容数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    per := Person&#123;</span><br><span class="line">        Name: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">        Age:  <span class="number">8</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;原始struct的内存地址是：%p&quot;</span>, &amp;per)</span><br><span class="line">    modifyStruct(per)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;改动后的值是: %v&quot;</span>, per)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyStruct</span><span class="params">(per Person)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;函数里接收到struct的内存地址是：%p&quot;</span>, &amp;per)</span><br><span class="line">    per.Age = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">原始<span class="keyword">struct</span>的内存地址是：<span class="number">0xc0000a6018</span></span><br><span class="line">函数里接收到<span class="keyword">struct</span>的内存地址是：<span class="number">0xc0000a6030</span></span><br><span class="line">改动后的值是: &#123;test <span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 思考题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 思考题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go函数返回局部变量的指针是否安全?</title>
      <link href="/2023/02/25/Go%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8/"/>
      <url>/2023/02/25/Go%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Go函数返回局部变量的指针是否安全"><a href="#Go函数返回局部变量的指针是否安全" class="headerlink" title="Go函数返回局部变量的指针是否安全?"></a>Go函数返回局部变量的指针是否安全?</h1><h2 id="参考解析"><a href="#参考解析" class="headerlink" title="参考解析"></a>参考解析</h2><p>一般来说，局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。</p><p>但这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上，因为他们不在栈区，即使释放函数，其内容也不会受影响。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">res := <span class="number">0</span></span><br><span class="line">res = x + y</span><br><span class="line"><span class="keyword">return</span> &amp;res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子中，函数 <code>add</code> 局部变量 <code>res</code> 发生了逃逸。res作为返回值，在 main 函数中继续使用，因此 res 指向的内存不能够分配在栈上，随着函数结束而回收，只能分配在堆上。</p><p>编译时可以借助选项 <code>-gcflags=-m</code>，查看变量逃逸的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./main.go:6:2: res escapes to heap:</span><br><span class="line">./main.go:6:2:   flow: ~r2 = &amp;res:</span><br><span class="line">./main.go:6:2:     from &amp;res (address-of) at ./main.go:8:9</span><br><span class="line">./main.go:6:2:     from return &amp;res (return) at ./main.go:8:2</span><br><span class="line">./main.go:6:2: moved to heap: res</span><br><span class="line">./main.go:12:13: ... argument does not escape</span><br><span class="line">0xc0000ae008</span><br></pre></td></tr></table></figure><p><code>res escapes to heap</code> 即表示 <code>res</code> 逃逸到堆上了。</p><h2 id="知识点补充—–go中的堆和栈"><a href="#知识点补充—–go中的堆和栈" class="headerlink" title="知识点补充—–go中的堆和栈"></a>知识点补充—–go中的堆和栈</h2><p>我们定义的变量存放在堆还是栈中？一般是这么来分配的</p><p>堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式类似于链表</p><p>栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><h3 id="那么go中的全局变量和局部变量都是放在哪里呢？"><a href="#那么go中的全局变量和局部变量都是放在哪里呢？" class="headerlink" title="那么go中的全局变量和局部变量都是放在哪里呢？"></a>那么go中的全局变量和局部变量都是放在哪里呢？</h3><h4 id="1-变量的声明周期"><a href="#1-变量的声明周期" class="headerlink" title="1. 变量的声明周期"></a>1. 变量的声明周期</h4><p>生命周期是指程序执行过程中变量存在的时间段。</p><p>（1）包变量(全局变量) 一直常驻在内存中直到程序的结束，然后被系统垃圾回收，也就是说包变量的生命周期是整个程序的执行时间</p><p>（2）局部变量 在函数中定义的变量，它有一个动态的生命周期：每次执行的时候就创建一个新的实体，一直生存到没有人使用(例如没有外部指针指向它，函数退出的时候没有路径访问到这个变量)这个时候它占用的空间就会被回收</p><h4 id="2-堆和栈的分配"><a href="#2-堆和栈的分配" class="headerlink" title="2. 堆和栈的分配"></a>2. 堆和栈的分配</h4><p><a href="https://zhuanlan.zhihu.com/p/523195006">如何判断 Golang 变量是分配在栈（stack）上还是堆（heap）上？</a></p><p>Go语言区别于C&#x2F;C++，虽然变量申请在堆空间上，但是它有自动回收垃圾的功能，所以这些堆地址空间也无需我们手动回收，系统会在需要释放的时刻自动进行垃圾回收。</p><p><strong>总结：Golang 变量存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。非指针小对象通常保存在栈上，大对象保存在堆上。至于指针保存在堆上还是栈上，要进行逃逸分析</strong></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 思考题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 思考题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang基础算法（一）</title>
      <link href="/2023/02/21/golang%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/21/golang%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言分解质因数"><a href="#Go语言分解质因数" class="headerlink" title="Go语言分解质因数"></a>Go语言分解质因数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个正整数分解质因数。例如：输入 90，打印出 90 &#x3D; 2 * 3 * 3 * 5。</p><h2 id="题目解决思路"><a href="#题目解决思路" class="headerlink" title="题目解决思路"></a>题目解决思路</h2><p>对 n 进行分解质因数，应先找到一个最小的质数 k，然后按下述步骤完成：</p><ol><li>如果这个质数恰等于 n，则说明分解质因数的过程已经结束，打印出即可。</li><li>如果 n 小于最小的质数 k，不能分解质因数，直接打印 n。</li><li>如果 n &gt; k，但 n 能被 k 整除，则应打印出 k 的值，并用 n 除以 k 的商,作为新的正整数 n，重复执行第一步。</li><li>如果 n 不能被 k 整除，则用 k+1 作为 k 的值，重复执行第一步。</li></ol><h2 id="代码具体实现"><a href="#代码具体实现" class="headerlink" title="代码具体实现"></a>代码具体实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n, i <span class="type">int</span> = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;请输入一个数:&quot;</span>)</span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d\n&quot;</span>, &amp;n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d = &quot;</span>, n)</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> n != i &#123;</span><br><span class="line"><span class="keyword">if</span> n % i == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d * &quot;</span>, i)</span><br><span class="line">n = n / i</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下</p><blockquote><p>请输入一个数:100<br>100 &#x3D; 2 * 2 * 5 * 5</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装MySQL，Redis</title>
      <link href="/2022/12/27/Docker%E5%AE%89%E8%A3%85MySQL,Redis/"/>
      <url>/2022/12/27/Docker%E5%AE%89%E8%A3%85MySQL,Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-安装-MySQL，Redis"><a href="#Docker-安装-MySQL，Redis" class="headerlink" title="Docker 安装 MySQL，Redis"></a>Docker 安装 MySQL，Redis</h1><h2 id="MySQL—–windows："><a href="#MySQL—–windows：" class="headerlink" title="MySQL—–windows："></a>MySQL—–windows：</h2><p>图形化界面和命令行操作都可，这里使用命令行演示</p><h3 id="1-查看可用版本"><a href="#1-查看可用版本" class="headerlink" title="1.查看可用版本"></a>1.查看可用版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><h3 id="2-拉取官方的最新版本的镜像"><a href="#2-拉取官方的最新版本的镜像" class="headerlink" title="2.拉取官方的最新版本的镜像"></a>2.拉取官方的最新版本的镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure><p>也可以根据需要的版本修改TAG，比如拉取mysql5.7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p>成功后显示：</p><p><code>Digest: sha256:8cf035b14977b26f4a47d98e85949a7dd35e641f88fc24aa4b466b36beecf9d6</code><br><code>Status: Downloaded newer image for mysql:5.7</code><br><code>docker.io/library/mysql:5.7</code></p><h3 id="3-查看本地镜像"><a href="#3-查看本地镜像" class="headerlink" title="3.查看本地镜像"></a>3.查看本地镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>可以看到两个版本的mysql镜像</p><p><code>REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</code><br><code>mysql        latest    4f06b49211c0   3 days ago    530MB</code><br><code>mysql        5.7       be16cf2d832a   3 weeks ago   455MB</code></p><h3 id="4-运行容器"><a href="#4-运行容器" class="headerlink" title="4.运行容器"></a>4.运行容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name mysql57 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br></pre></td></tr></table></figure><ul><li>-it 表示与容器进行交互式启动</li><li>-d 表示可后台运行容器（守护式运行）</li><li>–name 给新建的容器命名</li><li>-p 宿主机端口:容器端口 表示将容器的端口映射到宿主机上，通过宿主机访问内部端口（映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 <strong>宿主机ip:3306</strong> 访问到 MySQL 的服务）</li><li>-e MYSQL_ROOT_PASSWORD&#x3D;123456 设置 MySQL 服务 root 用户的密码</li></ul><h3 id="注意：这里如果使用最新的-mysql-latest，旧版本的-navicat-会无法连接，报2059错误"><a href="#注意：这里如果使用最新的-mysql-latest，旧版本的-navicat-会无法连接，报2059错误" class="headerlink" title="注意：这里如果使用最新的 mysql:latest，旧版本的 navicat 会无法连接，报2059错误"></a>注意：这里如果使用最新的 mysql:latest，旧版本的 navicat 会无法连接，报2059错误</h3><p>出现这个原因是mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password, 解决问题方法有两种,一种是升级navicat,一种是把mysql用户登录密码加密规则还原成mysql_native_password.</p><h4 id="方法：更改加密规则"><a href="#方法：更改加密规则" class="headerlink" title="方法：更改加密规则"></a>方法：更改加密规则</h4><h5 id="1-直接修改root用户-密码加密方式"><a href="#1-直接修改root用户-密码加密方式" class="headerlink" title="1.直接修改root用户 密码加密方式"></a>1.直接修改root用户 密码加密方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;   #修改加密规则  </span><br><span class="line">FLUSH PRIVILEGES;   #刷新权限  </span><br></pre></td></tr></table></figure><p> 现在再次打开Navicat Premium 连接MySQL数据库就会发现可以连接成功了</p><h5 id="2-创建数据库用户，修改其密码加密方式"><a href="#2-创建数据库用户，修改其密码加密方式" class="headerlink" title="2.创建数据库用户，修改其密码加密方式"></a>2.创建数据库用户，修改其密码加密方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#例如：创建用户test，允许连接的主机范围为192.168.1.0网段，使用旧密码机制，设置密码为123456</span><br><span class="line">create user &#x27;test&#x27;@&#x27;192.168.1.%&#x27; identified with mysql_native_password by &#x27;123456&#x27;;</span><br><span class="line">grant all on *.* to &#x27;test&#x27;@&#x27;192.168.1.%&#x27;;#对数据库用户test给予对全部数据库和表的所有权限（可按需求配置）</span><br><span class="line">flush privileges;#刷新权限</span><br></pre></td></tr></table></figure><p>再次打开Navicat Premium 就会发现可以连接成功了</p><h3 id="其他命令复习："><a href="#其他命令复习：" class="headerlink" title="其他命令复习："></a>其他命令复习：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#mysql单独重置密码命令：</span><br><span class="line">alter user &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;111111&#x27;;</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; PASSWORD EXPIRE NEVER;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;usernamexxx&#x27;@&#x27;hostxxx&#x27; IDENTIFIED BY &#x27;passwordxxx&#x27;;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>hostxxx：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</li><li>passwordxxx：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT privilegesxxx ON databasenamexxx.tablenamexxx TO &#x27;usernamexxx&#x27;@&#x27;hostxxx&#x27;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>privilegesxxx：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</li><li>databasenamexxx：数据库名</li><li>tablenamexxx：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示，如</em>.*</li></ul><p>参考链接：<a href="https://blog.csdn.net/huxinguang_ios/article/details/80887175">MySQL 创建用户并授权</a></p><h2 id="Redis—–windows："><a href="#Redis—–windows：" class="headerlink" title="Redis—–windows："></a>Redis—–windows：</h2><h3 id="1-查看可用版本-1"><a href="#1-查看可用版本-1" class="headerlink" title="1.查看可用版本"></a>1.查看可用版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure><h3 id="2-拉取官方的最新版本的镜像-1"><a href="#2-拉取官方的最新版本的镜像-1" class="headerlink" title="2.拉取官方的最新版本的镜像"></a>2.拉取官方的最新版本的镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:latest</span><br></pre></td></tr></table></figure><p>也可以根据需要的版本修改TAG</p><p>成功后显示：</p><p><code>Digest: sha256:6a59f1cbb8d28ac484176d52c473494859a512ddba3ea62a547258cf16c9b3ae</code><br><code>Status: Downloaded newer image for redis:latest</code><br><code>docker.io/library/redis:latest</code></p><h3 id="3-查看本地镜像-1"><a href="#3-查看本地镜像-1" class="headerlink" title="3.查看本地镜像"></a>3.查看本地镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><code>REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</code><br><code>mysql        latest    4f06b49211c0   3 days ago    530MB</code><br><code>redis        latest    2f66aad5324a   2 weeks ago   117MB</code><br><code>mysql        5.7       be16cf2d832a   3 weeks ago   455MB</code></p><h3 id="4-运行容器-1"><a href="#4-运行容器-1" class="headerlink" title="4.运行容器"></a>4.运行容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis -p 6379:6379 redis:latest</span><br></pre></td></tr></table></figure><ul><li><strong>-p 6379:6379</strong>：映射容器服务的 6379 端口到宿主机的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务。</li></ul><h3 id="5-通过-redis-cli-连接测试使用-redis-服务。"><a href="#5-通过-redis-cli-连接测试使用-redis-服务。" class="headerlink" title="5.通过 redis-cli 连接测试使用 redis 服务。"></a>5.通过 redis-cli 连接测试使用 redis 服务。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Bittersweet&gt; docker exec -it redis /bin/bash</span><br><span class="line">root@7690087a668e:/data# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; set test 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>也可以使用<strong>RESP</strong>图形界面连接测试</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoLand常用快捷键</title>
      <link href="/2022/11/22/goland%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2022/11/22/goland%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Goland快捷键设置"><a href="#Goland快捷键设置" class="headerlink" title="Goland快捷键设置"></a>Goland快捷键设置</h1><h4 id="File-gt-Settings-gt-Keymap"><a href="#File-gt-Settings-gt-Keymap" class="headerlink" title="File-&gt;Settings-&gt;Keymap"></a>File-&gt;Settings-&gt;Keymap</h4><h1 id="GoLand常用快捷键"><a href="#GoLand常用快捷键" class="headerlink" title="GoLand常用快捷键"></a>GoLand常用快捷键</h1><h3 id="1、查询快捷键"><a href="#1、查询快捷键" class="headerlink" title="1、查询快捷键"></a>1、查询快捷键</h3><pre><code>        CTRL+N 查找类        CTRL+SHIFT+N 查找文件        CTRL+SHIFT+ALT+N 查找类中的方法或变量        CTRL+B 快速打开光标处的类或方法        CTRL+ALT+B 找所有的子类        CTRL+SHIFT+B 找变量的类        CTRL+G 定位行        CTRL+F 在当前窗口查找文本        CTRL+SHIFT+F 在指定窗口查找文本        CTRL+R 在 当前窗口替换文本        CTRL+SHIFT+R 在指定窗口替换文本        ALT+SHIFT+C 查找修改的文件        CTRL+E 最近打开的文件        F3 向下查找关键字出现位置        SHIFT+F3 向上一个关键字出现位置        F4 查找变量来源        CTRL+ALT+F7 选中的字符查找工程出现的地方        CTRL+SHIFT+O 弹出显示查找内容        ALT+F1 查找文件所在目录位置        CTRL+H 显示类结构图        CTRL+Q 显示注释文档        CTRL+SHIFT+I 简短查看源定义        CTRL+SHIFT+P 查看表达式类型（在表达式上或者表达式末尾使用）</code></pre><h3 id="2、自动代码"><a href="#2、自动代码" class="headerlink" title="2、自动代码"></a>2、自动代码</h3><pre><code>        Alt+Enter 导入包,自动修正        CTRL+ALT+L 格式化代码        CTRL+ALT+I 自动缩进        CTRL+ALT+O 优化导入的类和包        ALT+INSERT 生成代码(如GET,SET方法,构造函数等)        CTRL+SHIFT+SPACE 自动补全代码        CTRL+空格 代码提示        CTRL+ALT+SPACE 类名或接口名提示        CTRL+P 方法参数提示        CTRL+J 自动代码        CTRL+ALT+T 把选中的代码放在 TRY&#123;&#125; IF&#123;&#125; ELSE&#123;&#125; 里        SHIFT+F6 重构-重命名        CTRL+I 实现接口        CTRL+SHIFT+Space 智能类型推断式返回（return关键字后使用）        CTRL+ALT+V 自动生成表达式返回值        CTRL+ALT+M 重构表达式为函数(光标在表达式末尾)        CTRL+Space 快速返回实现（return关键字后使用）</code></pre><h3 id="3、复制快捷方式"><a href="#3、复制快捷方式" class="headerlink" title="3、复制快捷方式"></a>3、复制快捷方式</h3><pre><code>        CTRL+D 复制行        CTRL+X 剪切,删除行</code></pre><h3 id="4、其他快捷方式"><a href="#4、其他快捷方式" class="headerlink" title="4、其他快捷方式"></a>4、其他快捷方式</h3><pre><code>        CIRL+U 大小写切换        CTRL+Z 倒退        CTRL+SHIFT+Z 向前        CTRL+ALT+F12 资源管理器打开文件夹        SHIFT+ALT+INSERT 竖编辑模式        Ctrl+/ 将当前行代码注释或取消注释        Ctrl+Shift+/ 在当前光标位置添加 /**/ 或将 /*xxxx*/ 内容取消注释        CTRL+W 选中代码，连续按会有其他效果        ALT+ ←/→ 切换代码视图        CTRL+ALT ←/→ 返回上次编辑的位置        ALT+ ↑/↓ 在方法间快速移动定位        ALT+1 快速打开或隐藏工程面板        CTRL+SHIFT+UP/DOWN 代码向上/下移动。        CTRL+UP/DOWN 光标跳转到第一行或最后一行下        ESC 光标返回编辑框        SHIFT+ESC 光标返回编辑框,关闭无用的窗口        ALT+J 相同单词多选        CTRL+SHIFT+A 工具调用        Ctrl+PageUp/PageDown 光标跳转到第一行或最后一行</code></pre>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 编程工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇</title>
      <link href="/2022/11/22/%E5%BC%80%E7%AF%87/"/>
      <url>/2022/11/22/%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="呆呆，晚上好"><a href="#呆呆，晚上好" class="headerlink" title="呆呆，晚上好"></a>呆呆，晚上好</h1><h2 id="嘀嘀嘀"><a href="#嘀嘀嘀" class="headerlink" title="嘀嘀嘀"></a>嘀嘀嘀</h2><div class="fj-gallery"><p><img src="https://source.fomal.cc/img/default_cover_9.webp" alt="p1"><br><img src="https://source.fomal.cc/img/default_cover_10.webp" alt="p2"> </p>          </div>]]></content>
      
      
      <categories>
          
          <category> 情感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
